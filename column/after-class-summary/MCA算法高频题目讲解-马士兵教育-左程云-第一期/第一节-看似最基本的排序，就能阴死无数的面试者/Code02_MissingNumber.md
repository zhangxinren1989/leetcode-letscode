这是一道leetcode原题

有关：荷兰国旗问题，类似快速排序中左右处理问题

## 41. 缺失的第一个正数
给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。

请你实现时间复杂度为 O(n) 并且只使用常数级别额外空间的解决方案。

## 题解
```
public static int firstMissingPositive(int[] arr) {
		// l是盯着的位置
		// 0 ~ L-1有效区
		int L = 0;
		int R = arr.length;
		while (L != R) {
			if (arr[L] == L + 1) {
				L++;
			} else if (arr[L] <= L || arr[L] > R || arr[arr[L] - 1] == arr[L]) { // 垃圾的情况
				swap(arr, L, --R);
			} else {
				swap(arr, L, arr[L] - 1);
			}
		}
		return L + 1;
	}

	public static void swap(int[] arr, int i, int j) {
		int tmp = arr[i];
		arr[i] = arr[j];
		arr[j] = tmp;
	}
```
### 题解说明
又是双指针，这题代码很短，理解起来不太容易，怎么找答案的最小正数，数组分三块，左边是找到的不缺的部分，右边是错误的部分，中间是将要处理的部分

因为最多length个数，所以预期最大能找到的数就是length，每找到一个数, L加1，那么哪些数是不可能（不要）的数呢，三种情况，一是重复的数，这种数会让最大能找到的数的预期变小，一是过大的数，比如预期最大能找到10，当前的数是12，那也不能要，而且也会让预期的数变小

哪些数是可以的呢，当前该要的数，比如当前L在0位置，想要1，正好现在的数是1，或者之面该要的数，比如当前L在0位置，想要1，最大预期的数是10，现在的数是5，而索引4位置不是5，数没有重复，那么把5放到4位置，5位置的数换到当前位置（交换）

其实不能要的数，也是通过交换，而到右边，不能要的数的三种情况

- arr[L] <= L 当前位置比L还小，其实就是跟已经找到不缺的数重了，已经有这个数了，不能要，
- arr[L] > R 当前位置比预期最大值还大，不能要
- arr[arr[L] - 1] == arr[L] 这个就是当前的数跟后面正确位置上的数重了，也不能要，举个例子，当前L=2， arr[L]=8，8应该去哪个位置呢，去7，arr[arr[L] - 1] = arr[8-1] = arr[7] == arr[L] = 8，这个等式的意思就是在他应该去的位置已经是应该有的那个数了，所以现在的数重了，也就是多了，不能要

这么一说可能看得人有一点感觉，主要就是数组分三个部分，每个部分的情况再细分，arr[arr[L] - 1] == arr[L]这个不好理解